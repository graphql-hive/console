---
title: 'Authorization'
---

import { Callout } from '#components/callout';

# Authorization

Authorization directives allow you to define fine-grained access control directly in your GraphQL schema. Instead of handling authorization logic in resolvers, you declare which fields and types require authentication or specific scopes using directives. The router enforces these rules before calling your subgraphs, ensuring consistent protection across your federated graph.

For the complete configuration reference, see [`authorization` configuration](../configuration/authorization).

## How Authorization Directives Work

When a GraphQL request arrives at the router, it goes through these steps:

1. **Request arrives** with user credentials (typically a JWT token)
2. **Router extracts user information** from the token (authentication status and scopes)
3. **Router checks each field** in the requested query against authorization directives
4. **Access is allowed or denied** based on the field's directive requirements and the user's credentials
5. **Response is returned** with either the requested data, errors, or a full rejection


<Callout type="note">
    Authorization happens **before** your subgraphs are called, protecting sensitive fields at the router level.
</Callout>

## Integration with JWT Authentication

Authorization directives work alongside your [JWT authentication setup](./jwt-authentication.mdx). When a request arrives, the router validates the JWT token and extracts scopes from the JWT claims (in the `scope` field). It then checks the authorization directives in your schema against these extracted scopes to determine if the query should proceed or fail.

```yaml filename="router.config.yaml"
jwt:
  require_authentication: false
  jwks_providers:
    - source: remote
      url: https://your-auth-provider.com/.well-known/jwks.json

authorization:
  directives:
    enabled: true
    unauthorized:
      mode: filter  # Or 'reject'
```

## Authorization Directives

### `@authenticated`

Marks a field or type as requiring authentication. Anonymous requests cannot access these fields.

```graphql
extend schema @link(
  url: "https://specs.apollo.dev/federation/v2.9"
  import: ["@authenticated"]
)

type Query {
  publicPosts: [Post]               # Anyone
  myDrafts: [Post] @authenticated   # Authenticated users only
}

type User {
  id: ID!
  username: String!
  bio: String
  email: String @authenticated      # Private field
}
```

### `@requiresScopes`

Provides granular control by requiring specific scopes (permissions stored in JWT token).

- **Single list** (AND logic): User must have **all** scopes in the list
- **Multiple lists** (OR logic): User must satisfy **any** complete list

```graphql
extend schema @link(
  url: "https://specs.apollo.dev/federation/v2.9"
  import: ["@requiresScopes"]
)

type Query {
  users: [User]
  # Requires both scopes
  billingReport: String @requiresScopes(scopes: [["admin", "billing:read"]])
  # Requires either scope
  allUsers: [User] @requiresScopes(scopes: [["read:admin"], ["manage:users"]])
}

type User {
  id: ID!
  username: String!
  email: String @requiresScopes(scopes: [["email:read"]])
}
```

## Directives on Types and Fields

**Type-level directives** protect all fields of that type:

```graphql
type AdminPanel @authenticated {
  users: [User!]
  logs: [String!]
}
```

**Field-level directives** add additional restrictions beyond type-level protection:

```graphql
type User @authenticated {
  id: ID!
  username: String!
  email: String @requiresScopes(scopes: [["email:read"]])  # Requires auth + scope
  name: String  # Requires auth only
}
```

Field requirements are combined with type requirements using `AND` logic.

## Combining Directives Across Federated Types

When a type is defined across multiple subgraphs, all authorization requirements are combined using `AND`. A user must satisfy requirements from all subgraphs.

### Type-Level Composition

Consider a `Product` type split across inventory and pricing services. Each subgraph applies its own authorization directive, and when the type is composed in the supergraph, both requirements must be met.

```graphql filename="Inventory subgraph"
type Product @key(fields: "id") @authenticated {
  id: ID!
  inStock: Int
}
```

```graphql filename="Pricing subgraph"
type Product @key(fields: "id") @requiresScopes(scopes: [["pricing:read"]]) {
  id: ID!
  price: Float
}
```

To access `Product`, user must be authenticated **AND** have `pricing:read` scope.

```graphql filename="Supergraph"
type Product @authenticated @requiresScopes(scopes: [["pricing:read"]]) {
  id: ID!
  price: Float
  inStock: Int
}
```

### Field-Level Composition

When the same field exists in multiple subgraphs with different authorization directives, the requirements are merged. Consider a `username` field that appears in both the accounts and profile services with different access controls:

```graphql filename="Accounts subgraph"
type User @key(fields: "id") {
  id: ID!
  username: String @shareable @requiresScopes(scopes: [["user:read"]])
}
```

```graphql filename="Profile subgraph"
type User @key(fields: "id") {
  id: ID!
  username: String @shareable @requiresScopes(scopes: [["profile:read"]])
}
```

In the supergraph, both requirements are combined using `AND`:

```graphql filename="Supergraph"
type User {
  id: ID!
  username: String @requiresScopes(scopes: [["user:read", "profile:read"]])
}
```

To access `User.username`, a client must have **both** `user:read` AND `profile:read` scopes, ensuring they meet the access requirements from all subgraphs where the field is defined.

### Merging `@requiresScopes`

When `@requiresScopes` appears on the same entity across multiple subgraphs, the policies are merged by combining scope groups with logical AND:

1. **Combine groups**: For each pair of scope groups (one from each policy), create a new group containing the union of both.
2. **Remove redundant groups**: Drop any group that is a superset of another - this eliminates overly permissive conditions that would make stricter requirements redundant.

Let's illustrate this with an example, where two subgraphs define different scope requirements for the same entity.

```graphql filename="Subgraph A"
@requiresScopes(scopes:[["user:read", "user:email:read"], ["admin"]])
```

```graphql filename="Subgraph B"
@requiresScopes(scopes:[["user:read", "billing:read"], ["admin", "billing:invoice:read"]])
```

The merged state of intermediate groups before simplification:

```graphql
@requiresScopes(scopes: [
  ["user:read", "user:email:read", "billing:read"],
  ["user:read", "user:email:read", "admin", "billing:invoice:read"],
  ["admin", "user:read", "billing:read"],
  ["admin", "billing:invoice:read"]
])
```

As you can see, the second group is a superset of the first and third groups, so they can be removed.

```graphql
@requiresScopes(scopes: [
  ["user:read", "user:email:read", "billing:read"],
  ["admin", "billing:invoice:read"]
])
```

The composition process automatically simplified the merged policy by removing redundant scope groups.

## Authorization Rules by GraphQL Type

### Object Types
Auth directives can be applied at type and field levels. Requirements are combined using AND.

### Scalars and Enums
Can have auth directives applied. When returned in a field, combined with field-level requirements.

### Interface Types
Auth directives on interfaces are **disallowed**. Instead, apply directives to concrete implementing types. The effective policy for an interface is the logical `AND` of all implementing types' policies.

```graphql
# Disallowed
interface Item @authenticated { ... }

# Allowed - apply to concrete types
type Book implements Item @authenticated {
  id: ID!
  title: String @requiresScopes(scopes: [["book:read"]])
}

type Video implements Item @requiresScopes(scopes: [["video:read"]]) {
  id: ID!
  title: String
}
```

When querying the interface directly, the combined policy from all implementing types is applied.

### Union Types
Auth directives on unions are **prohibited**. Apply directives to concrete member types instead. This aligns with federation rules and avoids ambiguity.

## Field-Level Dependencies (`@requires`)

A field using `@requires` to access fields from another entity must define an authorization policy that is a **superset** of the policies on all required fields. This prevents bypassing security policies through federated queries.

## Handling Authorization Errors

The router supports two modes for handling authorization violations:

### Filter Mode (Default)

Unauthorized fields are removed from the response, but the query continues processing. An error is added for each removed field.

```graphql
query {
  dashboard {
    publicMetrics      # Authorized âœ“
    adminPanel         # Unauthorized - filtered out
  }
}
```

Response:
```json
{
  "data": {
    "dashboard": {
      "publicMetrics": { ... },
      "adminPanel": null
    }
  },
  "errors": [
    {
      "message": "Unauthorized field or type",
      "extensions": { "code": "UNAUTHORIZED_FIELD_OR_TYPE" }
    }
  ]
}
```

### Reject Mode

If a user tries to access any unauthorized field, the entire request is rejected and no data is returned.

```graphql
query {
  dashboard {
    publicMetrics      # Authorized
    adminPanel         # Unauthorized - entire request rejected
  }
}
```

Response:
```json
{
  "data": null,
  "errors": [
    {
      "message": "Unauthorized field or type",
      "extensions": { "code": "UNAUTHORIZED_FIELD_OR_TYPE" }
    }
  ]
}
```

Enable reject mode by setting `unauthorized.mode: reject` in your router configuration.
