diff --git a/dist/server/compile.js b/dist/server/compile.js
index 4b3f41397995dd4c796f6945627fb14d43776eb3..3b05b570b76308391453fe0516c23bd482fe8874 100644
--- a/dist/server/compile.js
+++ b/dist/server/compile.js
@@ -142,7 +142,8 @@ async function compileMdx(source, {
           rehypeTwoslashPopup,
           [rehypeAttachCodeMeta, { search }]
         ],
-        rehypeExtractTocContent
+        rehypeExtractTocContent,
+        rehypeFrontmatterRelativeImages
       ].filter((v) => !!v),
       recmaPlugins: [
         ...recmaPlugins || [],
@@ -154,3 +155,94 @@ async function compileMdx(source, {
 export {
   compileMdx
 };
+
+function rehypeFrontmatterRelativeImages() {
+  return (ast, file) => {
+    // Skip processing if there's no file history
+    if (!file.history || !file.history.length) return ast;
+    
+    const filePath = file.history[0];
+    const imports = [];
+    const imported = new Map();
+    
+    // Find frontmatter node - check for metadata, frontmatter, or data exports
+    const possibleExportNames = ['metadata', 'frontmatter', 'data'];
+    const frontMatterNode = ast.children.find((node) => {
+      if (node.type !== 'mdxjsEsm' || !node.data?.estree?.body?.[0]) return false;
+      
+      const firstNode = node.data.estree.body[0];
+      
+      // Check if it's an export declaration
+      if (firstNode.type !== 'ExportNamedDeclaration' || 
+          !firstNode.declaration?.declarations?.[0]?.id?.name) return false;
+      
+      // Check if it's one of our target export names
+      return possibleExportNames.includes(firstNode.declaration.declarations[0].id.name);
+    });
+    
+    if (!frontMatterNode || !frontMatterNode.data?.estree?.body?.[0]?.declaration?.declarations?.[0]?.init?.properties) {
+      return ast;
+    }
+    
+    // Get frontmatter properties
+    const properties = frontMatterNode.data.estree.body[0].declaration.declarations[0].init.properties;
+    
+    // Find thumbnail and image properties
+    for (const prop of properties) {
+      // Skip if not the properties we're looking for
+      if (prop.key?.value !== 'thumbnail' && prop.key?.value !== 'image') continue;
+      
+      // Skip if not a string literal
+      if (prop.value?.type !== 'Literal' || typeof prop.value.value !== 'string') continue;
+      
+      const imagePath = prop.value.value;
+      
+      let value;
+      if (imagePath.startsWith('./') || imagePath.startsWith('../')) {
+        value = imagePath;
+      } else {
+        value = `./${imagePath}`;
+      }
+      
+      // Create a unique import name
+      let name = imported.get(value);
+      
+      if (!name) {
+        name = `_frontMatterImage${imported.size}`;
+        
+        // Create an import declaration
+        imports.push({
+          type: 'ImportDeclaration',
+          source: { type: 'Literal', value },
+          specifiers: [{ 
+            type: 'ImportDefaultSpecifier', 
+            local: { type: 'Identifier', name } 
+          }]
+        });
+        
+        imported.set(value, name);
+      }
+      
+      // Replace the string value with the identifier reference
+      prop.value = { type: 'Identifier', name };
+    }
+    
+    // Add the imports to the AST if we have any
+    if (imports.length > 0) {
+      // Add imports to the beginning of the AST as a new mdxjsEsm node
+      ast.children.unshift({
+        type: 'mdxjsEsm',
+        value: '',
+        data: {
+          estree: {
+            type: 'Program',
+            sourceType: 'module',
+            body: imports
+          }
+        }
+      });
+    }
+    
+    return ast;
+  };
+}
